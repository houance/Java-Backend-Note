# 算法与数据结构-笔记

[toc]

## 数组

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-09-53.png" alt="Screenshot from 2021-03-05 23-09-53" style="zoom:80%;" />

+ **综述**

  > 1. 数组是线性表 -- 数据只有前后两个方向, 类似的有链表, 队列, 栈
  >2. 数组在内存空间中是连续
  > 3. `数组` 储存基本类型 ( int, float... ),  `容器` 储存对象 ( Java 中的 Array List )
  >4. 数组 `随机(任意)访问` 快速, `插入` 和 `删除` 比较慢.
  > 5. 业务开发使用 `容器`, 底层开发使用 `数组`
  > 6. `动态数组/容器` 在扩容的时候需要做 `数据迁移`, 比较耗时
  
+ **数组插入技巧**

  > 1. 如果数组是 `无序` 的, 只需要将插入位置的原数据, 挪到数组最后, 新数组放到插入位置, 即可完成插入, 避免 `大规模的数据搬移`
  >
  > 2. 复杂度 = O(1)

  ![Screenshot from 2021-02-20 14-55-06](%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-02-20%2014-55-06.png)

+ **数组删除技巧**

  > 1. `只记录` 被删除的数据, 内存空间不足的时候, 才执行真正的删除动作, 避免每次删除, 都要执行 `大规模的数据搬移`
  > 2. 删除数组尾部数据的复杂度 = O(1)
  > 3. 删除数组头部数据的复杂度 = O(1)

  ![Screenshot from 2021-02-20 14-55-26](%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-02-20%2014-55-26.png)

## 链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-11-20.png" alt="Screenshot from 2021-03-05 23-11-20" style="zoom:80%;" />

+ **综述**

  > 1. 内存 `不连续`

### 单链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-12-33.png" alt="Screenshot from 2021-03-05 23-12-33" style="zoom:150%;" />

+ **综述**

  > 1. 插入, 删除的 `时间复杂度为 O(1)`
  > 2. `任意(随机)` 访问的 `时间复杂度为 O(n)`

### 循环链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-15-28.png" alt="Screenshot from 2021-03-05 23-15-28" style="zoom:150%;" />

+ **综述**

  > 1. `链尾到链头` 很方便, 适合环形结构( 约瑟夫问题 )
  > 2. 时间复杂度与 `单链表` 一致

### 双向链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-06%2012-37-45.png" alt="Screenshot from 2021-03-06 12-37-45" style="zoom:150%;" />

+ **综述**

  > 1. 理论上 `增加, 删除, 遍历` 的复杂度与上述一致
  >
  > 2. 如果 `删除` 的是 `给定指针的节点` , 则时间复杂度为 `O(1)` 
  >
  >    > 因为 `单链表` 无法获得指定结点的 `前置结点` , 所以总的时间是 `2O(n)`
  >    >
  >    > 而 `双向链表` 可以
  >
  > 3. `有序双向链表`的 `查询` 也比上述链表快速.
  >
  >    <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram.png" alt="Untitled Diagram" style="zoom:150%;" />
  >
  > 4. 双向链表属于 `空间换时间` 
  >
  >    > 因为 `双向链表` 需要储存两个指针

### 数组与链表比较

+ **性能**

  ![Screenshot from 2021-03-17 22-04-12](%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-17%2022-04-12.png)

+ **储存**

  > + **数组**
  >
  >   > 1. 数组的储存需要 `连续的内存空间`, 对 `CPU` 的缓存机制友好
  >   >
  >   >    > `CPU` 会预读一段 `连续的内存空间` --> `缓存命中机制`
  >   >
  >   > 2. 数组扩容涉及 `数据搬移`, 耗时长
  >
  > + **链表**
  >
  >   > 1. 链表不需要 `连续的内存空间`, 对 `CPU` 缓存机会不友好
  >   > 2. 频繁地 `插入, 删除` 操作会产生大量 `GC` .

### 编写链表代码

+ **引用和值传递**

  > 1. Java 是 `值传递`
  >
  > 2. 当参数是 `基本数据类型` 时, 传递参数传递的是 `数据的 Copy`, 不会改变原来的数据, 
  >
  > 3. 当参数是 `对象( Object )`时, 传递参数传递的是 `对象的引用( Object Reference )`, 改变参数 `会改变原来的对象`.
  >
  > 4. 示例代码和图示
  >
  >    > ```java
  >    > public static void main(){
  >    >     Person person1 = new Person("john", 31);
  >    >     Person person2;
  >    >     
  >    >     person2 = person1;
  >    >     person2.ChangeName("mary");
  >    >     System.out.Println(person1.getName());
  >    >     // Mary
  >    > }
  >    > ```
  >    >
  >    > 

---

## 二叉树

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-04-14%2023-05-11.png" alt="Screenshot from 2021-04-14 23-05-11" style="zoom:150%;" />

  > 1. 二叉树每个结点都可以有 `左右两个结点`

+ **二叉树分类**

  > 1. 上图的 2 号图是 `满二叉树`, 即每个结点`都有两个子结点`
  >
  > 2. 上图的 3 号图是 `完全二叉树`
  >
  >    > 1. 除了**最后一层**, 全部结点 `都有两个子结点`
  >    > 2. 最后一层的结点靠左排列, 即 `没有单独的右结点`
  >    > 3. **完全二叉树**适合`使用数组储存`( 完全利用数据空间 )

+ **二叉树遍历( 递归的思想 )**

  > 1. 前序遍历 : 中 --> 左 --> 右
  > 2. 中序遍历 : 左 --> 中 --> 右
  > 3. 后序遍历 : 左 --> 右 --> 中