# 算法与数据结构-笔记

[toc]

## 1. 数组

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-09-53.png" alt="Screenshot from 2021-03-05 23-09-53" style="zoom:80%;" />

+ **综述**

  > 1. 数组是线性表 -- 数据只有前后两个方向, 类似的有链表, 队列, 栈
  >2. 数组在内存空间中是连续
  > 3. `数组` 储存基本类型 ( int, float... ),  `容器` 储存对象 ( Java 中的 Array List )
  >4. 数组 `随机(任意)访问` 快速, `插入` 和 `删除` 比较慢.
  > 5. 业务开发使用 `容器`, 底层开发使用 `数组`
  > 6. `动态数组/容器` 在扩容的时候需要做 `数据迁移`, 比较耗时
  
+ **数组插入技巧**

  > 1. 如果数组是 `无序` 的, 只需要将插入位置的原数据, 挪到数组最后, 新数组放到插入位置, 即可完成插入, 避免 `大规模的数据搬移`
  >
  > 2. 复杂度 = O(1)

  ![Screenshot from 2021-02-20 14-55-06](%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-02-20%2014-55-06.png)

+ **数组删除技巧**

  > 1. `只记录` 被删除的数据, 内存空间不足的时候, 才执行真正的删除动作, 避免每次删除, 都要执行 `大规模的数据搬移`
  > 2. 删除数组尾部数据的复杂度 = O(1)
  > 3. 删除数组头部数据的复杂度 = O(1)

  ![Screenshot from 2021-02-20 14-55-26](%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-02-20%2014-55-26.png)

## 2. 链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-11-20.png" alt="Screenshot from 2021-03-05 23-11-20" style="zoom:80%;" />

+ **综述**

  > 1. 内存 `不连续`

### 2.1 单链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-12-33.png" alt="Screenshot from 2021-03-05 23-12-33" style="zoom:150%;" />

+ **综述**

  > 1. 插入, 删除的 `时间复杂度为 O(1)`
  > 2. `任意(随机)` 访问的 `时间复杂度为 O(n)`

### 2.2 循环链表

+ **结构**

  <img src="%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-03-05%2023-15-28.png" alt="Screenshot from 2021-03-05 23-15-28" style="zoom:150%;" />

+ **综述**

  > 1. `链尾到链头` 很方便, 适合环形结构( 约瑟夫问题 )
  > 2. 时间复杂度与 `单链表` 一致

### 2.3 双向链表

+ **结构**
+ **综述**