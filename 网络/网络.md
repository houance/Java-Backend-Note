# 网络

# 网络传输模型( TCP/IP Model)

## **结构**

<img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-31-03.png" alt="Screenshot from 2021-04-07 15-31-03" style="zoom:150%;" />



> 1. **应用层 ( Application )**
>
>    > 1. 使用`各种协议, 服务`等与用户交互
>    > 2. `数据生成`, 加密/解密, 压缩/解压
>    > 3. RPC 数据交互
>

> 1. **传输层 ( Transport )**
>
>    > 1. `管理端口`, 多个服务在`不同机器`上交互
>    > 2. `数据传输( TCP, UDP )`和推流( SCTP )
>    > 3. `连接管理` ( TCP 三次握手, UDP 断开......)
>

> 1. **网络层 ( Network/Internet )**
>
>    > 1. 提供` IP 地址`
>    > 2. 路由和转发
>    > 3. 通讯质量控制( 控制带宽...... )
>    > 4. 实现`无连接`的网络服务
>

> 1. **网络访问层**
>
>    1. **数据链路层**
>
>       > 1. MAC 地址
>       > 2. 封装帧( Frame ), 即添加`头部和尾部`
>       > 3. 错误检测 ( CRC )
>
>    2. **物理层**
>
>       > 1. 二进制发送



## **传输过程**

<img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-32-11.png" alt="Screenshot from 2021-04-07 15-32-11" style="zoom: 200%;" />

> 1. 数据在**应用层**准备就绪
> 2. **传输层**将数据`分成多个小段( Segments )`, 并为每个小段 `加上传输头`
> 3. **网络层** 为每个小段`加上网络头`
> 4. **数据链路层** 将每个小段  `加上头和尾`
> 5. **物理层** 转为 `二进制并发送`



# 网络协议

## **总览**

<img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-31-31.png" alt="Screenshot from 2021-04-07 15-31-31" style="zoom:150%;" />



# DNS

## **综述**

> 1. 负责根据 `域名( baidu.com, google.com 等)` 查找 `IP 地址` 
> 2. **DNS** 使用 `UDP` 协议实现



## **流程**

<img src="%E7%BD%91%E7%BB%9C.assets/DNS.png" alt="DNS" style="zoom:150%;" />

> 1. 以询问 **baidu.com** 为例子
> 2. `浏览器` 从**本地缓存**中寻找  `IP 地址`
> 3. 如果没有, 则向 **运营商** 询问 `IP 地址`
> 4. 运营商 向 **根服务器( 存储域名服务器的 IP 地址 )** 询问 `IP 地址`, 返回 **域名服务器** 的 `IP 地址` 
> 5. 运营商 向 **域名服务器( TLD SERVER, 储存 .com, .cn 等域名所对应的服务器 )** 询问 `IP 地址` , 返回存储所有 `.com 域名` 的服务器 `IP 地址`
> 6. 运营商 向 **Name Server** 询问 `IP 地址` , 返回 `baidu.com` 的 `IP 地址`
> 7. 运营商将 `baidu.com 的 IP 地址` 保存在缓存中, 向服务器返回 `IP 地址`



# TCP

## **TCP Header**

![Screenshot from 2021-04-07 23-25-35](%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2023-25-35.png)

> 1. **Seq Number( 序列号 )**
>
>    > 用于`三次握手`和重组 `Segments`
>
> 2. **Ack Number( 确认号 )**
>
>    > 用于`三次握手`和重组 `Segments`
>
> 3. **Flags( 标志位 )**
>
>    > 1. **URG** : 紧急标志
>    >
>    > 2. **ACK**
>    >
>    >    > 确认标志, 大多数情况下`置 1, 表示确认号有效`
>    >
>    > 3. **PSH**
>    >
>    >    > 推位标志, `置 1 表示不再接受数据`, 并尽快转由应用处理
>    >
>    > 4. **RST** : 复位标志, 用于恢复相应的 TCP 连接
>    >
>    > 5. **SYN**
>    >
>    >    > 复位标志, `仅在三次握手`的时候为 1, 表示序列号为`初始序列号`
>
> 4. **CheckSum( 校验和 )**
>
>    > 发送端`根据数据内容`计算的一个结果, `由接收端进行验证.`



## [面试题]**三次握手**

<img src="%E7%BD%91%E7%BB%9C.assets/three%20way%20handshake.jpeg" alt="three way handshake" style="zoom:150%;" />

### **过程**

> 1. 客户端发送 `SYN=1， seq=x( 随机生成 )` , 进入 `SYN-SENT` 状态
>
> 2. 服务端接受后, 发送`SYN=1, ACK=1, seq=y( 随机生成 ), ack=x+1` , 进入 `SYN-RCVD` 状态
>
>    > 1. 发出的 `ack = 接收的 seq +1`
>
> 3. 客户端接受后, 发送 `ACK=1, seq=x+1, ack=y+1` , 进入 `EXTABLISHED` 状态
>
>    > 发出的 `seq= 接收的 ack`
>
> 4. 服务端接受后, 也进入 `EXTABLISHED` 状态



### **意义**

> 1. **发送方** 需要`创建端口`发送数据
> 2. 如果没有 `第三次握手` , 服务端`并不知情`客户端**是否收到信息**
> 3. 如果客户端没有收到服务端信息, 则会`重新进行握手`
> 4. 此时服务端会 `新开一个端口`发送**第二次握手**, 造成了端口的浪费



## [面试题]**四次挥手**

<img src="%E7%BD%91%E7%BB%9C.assets/four%20way%20handshake.jpg" alt="four way handshake" style="zoom:200%;" />

### **过程**

> 1. 客户端发送 `FIN=1, seq=u( 随机生成 )`, 进入 `FIN-WAIT-1 状态`
> 2. 服务端接收后, 发送` ACK=1, seq=v( 随机生成 ), ack=u+1`, 检查**是否还有数据要发送**, 然后进入 `CLOSE-WAIT 状态`
> 3. 客户端接收后进入 `FIN-WAIT-2 状态`
> 4. 服务端发送数据后, 发送`FIN=1 , ACK=1, seq=w( 随机生成 ), ack=u+1`, 进入 `LAST-ACK 状态`
> 5. 客户端接收后, 发送 `ACK=1, seq=u+1, ack=w+1`, 进入 `TIME-WAIT 倒计时状态`, 倒计时结束后`关闭连接`
> 6. 服务端收到后`关闭连接`



### [面试题]**意义**

> 1. 为什么是四次挥手, 不是三次
>
>    > 1. 三次握手中, 第二次握手 `SYN 和 FIN 可以一起发送`, 因为此时没有数据需要传递
>    >
>    > 2. 四次挥手中, 第二次挥手之后因为`还可能需要发送数据`, 所以 `FIN 和 ACK 要分两次发送`
>    >
>    >    
>
> 2. 为什么要 **TIME_WAIT**
>
>    > 1. **如果第三次挥手丢失**, 服务端会`重新发送一次`, 这样客户端在 `TIME_WAIT 的状态` 就会收到这次挥手, 成功关闭连接
>    > 2. 经过 `TIME_WAIT` 时间后, 使**本次连接**产生的`报文段都消失`, 防止影响`下一次的连接`



# UDP

## UPD 头

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717175151.png)



# HTTP

### **综述**

> 1. **HTTP** 是`无状态`的, 通常使用 `Cookie, Sessions` 等记录用户状态
> 2. 



### **方法**

#### **GET**

+ **综述**

  > 从 **服务器** 取 `数据`

+ **要点**

  > 1. **GET** 方法会将数据以 **name=value?** 的形式 `明文` 添加到 `URL 后面` , 有可能造成`数据泄露`
  > 2. **GET** 方法最大数据量为 `1024 字节( URL 最大长度 )`



#### **POST**

+ **综述**

  > `提交数据` 到 **服务器**

+ **要点**

  > 1. **POST** 方法将数据添加到 `HTTP Header / Body`, 然后传输到指定的 **URL**



#### **PUT**

+ **综述**

  > 将 `数据保存` 在 **服务器**

+ **要点**

  > 



#### **DELETE**

+ **综述**

  > 将数据 `从服务器` 删除

+ **要点**



+ **HTTP 请求**

+ **HTTP 响应**



# HTTPS

