# 网络

[toc]

## 1. 网络传输模型( TCP/IP Model)

+ **结构**

  <img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-31-03.png" alt="Screenshot from 2021-04-07 15-31-03" style="zoom:150%;" />

  > 1. **应用层 ( Application )**
  >
  >    > 1. 使用`各种协议, 服务`等与用户交互
  >    > 2. `数据生成`, 加密/解密, 压缩/解压
  >    > 3. RPC 数据交互
  >
  > 2. **传输层 ( Transport )**
  >
  >    > 1. `管理端口`, 多个服务在`不同机器`上交互
  >    > 2. `数据传输( TCP, UDP )`和推流( SCTP )
  >    > 3. `连接管理` ( TCP 三次握手, UDP 断开......)
  >
  > 3. **网络层 ( Network/Internet )**
  >
  >    > 1. 提供` IP 地址`
  >    > 2. 路由和转发
  >    > 3. 通讯质量控制( 控制带宽...... )
  >    > 4. 实现`无连接`的网络服务
  >
  > 4. **网络访问层**
  >
  >    1. **数据链路层**
  >
  >       > 1. MAC 地址
  >       > 2. 封装帧( Frame ), 即添加`头部和尾部`
  >       > 3. 错误检测 ( CRC )
  >
  >    2. **物理层**
  >    
  >       > 1. 二进制发送

+ **传输过程**

  <img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-32-11.png" alt="Screenshot from 2021-04-07 15-32-11" style="zoom: 200%;" />
  
  > 1. 数据在**应用层**准备就绪
  > 2. **传输层**将数据`分成多个小段( Segments )`, 并为每个小段 `加上传输头`
  > 3. **网络层** 为每个小段`加上网络头`
  > 4. **数据链路层** 将每个小段  `加上头和尾`
  > 5. **物理层** 转为 `二进制并发送`

## 2. 网络协议

+ **总览**

  <img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-31-31.png" alt="Screenshot from 2021-04-07 15-31-31" style="zoom:150%;" />



## 3. DNS

+ **综述**

  > 1. 负责根据 `域名( baidu.com, google.com 等)` 查找 `IP 地址` 

+ **流程**

  <img src="%E7%BD%91%E7%BB%9C.assets/DNS.png" alt="DNS" style="zoom:150%;" />

  > 1. 以询问 **baidu.com** 为例子
  > 2. `浏览器` 从**本地缓存**中寻找  `IP 地址`
  > 3. 如果没有, 则向 **运营商** 询问 `IP 地址`
  > 4. 运营商 向 **根服务器( 存储域名服务器的 IP 地址 )** 询问 `IP 地址`, 返回 **域名服务器** 的 `IP 地址` 
  > 5. 运营商 向 **域名服务器( TLD SERVER, 储存 .com, .cn 等域名所对应的服务器 )** 询问 `IP 地址` , 返回存储所有 `.com 域名` 的服务器 `IP 地址`
  > 6. 运营商 向 **Name Server** 询问 `IP 地址` , 返回 `baidu.com` 的 `IP 地址`
  > 7. 运营商将 `baidu.com 的 IP 地址` 保存在缓存中, 向服务器返回 `IP 地址`

## 4. TCP

+ **TCP Header**

  ![Screenshot from 2021-04-07 23-25-35](%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2023-25-35.png)

  > 1. **Seq Number( 序列号 )**
  >
  >    > 用于`三次握手`和重组 `Segments`
  >
  > 2. **Ack Number( 确认号 )**
  >
  >    > 用于`三次握手`和重组 `Segments`
  >
  > 3. **Flags( 标志位 )**
  >
  >    > 1. **URG** : 紧急标志
  >    >
  >    > 2. **ACK**
  >    >
  >    >    > 确认标志, 大多数情况下`置 1, 表示确认号有效`
  >    >
  >    > 3. **PSH**
  >    >
  >    >    > 推位标志, `置 1 表示不再接受数据`, 并尽快转由应用处理
  >    >
  >    > 4. **RST** : 复位标志, 用于恢复相应的 TCP 连接
  >    >
  >    > 5. **SYN**
  >    >
  >    >    > 复位标志, `仅在三次握手`的时候为 1, 表示序列号为`初始序列号`
  >
  > 4. **CheckSum( 校验和 )**
  >
  >    > 发送端`根据数据内容`计算的一个结果, `由接收端进行验证.`

+ **三次握手( Three Way HandShake )**

  <img src="%E7%BD%91%E7%BB%9C.assets/three%20way%20handshake.jpeg" alt="three way handshake" style="zoom:150%;" />

  + **过程**

    > 1. 客户端发送 `SYN=1， seq=x( 随机生成 )` , 进入 `SYN-SENT` 状态
    >
    > 2. 服务端接受后, 发送`SYN=1, ACK=1, seq=y( 随机生成 ), ack=x+1` , 进入 `SYN-RCVD` 状态
    >
    >    > 1. 发出的 `ack = 接收的 seq +1`
    >
    > 3. 客户端接受后, 发送 `ACK=1, seq=x+1, ack=y+1` , 进入 `EXTABLISHED` 状态
    >
    >    > 发出的 `seq= 接收的 ack`
    >
    > 4. 服务端接受后, 也进入 `EXTABLISHED` 状态

  + **意义**

    > 1. **发送方** 需要`创建端口`发送数据
    > 2. 如果没有 `第三次握手` , 服务端`并不知情`客户端**是否收到信息**
    > 3. 如果客户端没有收到服务端信息, 则会`重新进行握手`
    > 4. 此时服务端会 `新开一个端口`发送**第二次握手**, 造成了端口的浪费

+ **四次挥手**

  