# 网络传输模型( TCP/IP Model)

## **结构**

<img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-31-03.png" alt="Screenshot from 2021-04-07 15-31-03" style="zoom: 80%;" />



**应用层 ( Application )**

1. 使用各种协议, 服务等与用户交互
2. 数据生成, 加密/解密, 压缩/解压
3. RPC 数据交互



**传输层 ( Transport )**

1. `管理端口`, 多个服务在`不同机器`上交互
2. `数据传输( TCP, UDP )`和推流( SCTP )
3. `连接管理` ( TCP 三次握手, UDP 断开......)



**网络层 ( Network/Internet )**

1. 提供` IP 地址`
2. 路由和转发
3. 通讯质量控制( 控制带宽...... )
4. 实现`无连接`的网络服务



**数据链路层**

1. MAC 地址
2. 封装帧( Frame ), 即添加`头部和尾部`
3. 错误检测 ( CRC )



**物理层**

1. 二进制发送



## **传输过程**

<img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-32-11.png" alt="Screenshot from 2021-04-07 15-32-11" style="zoom: 67%;" />



# 网络协议

## **总览**

<img src="%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2015-31-31.png" alt="Screenshot from 2021-04-07 15-31-31" style="zoom: 67%;" />



# DNS

## **综述**

1. 负责根据 `域名( baidu.com, google.com 等)` 查找 `IP 地址` 
2. **DNS** 使用 `UDP` 协议实现



## **流程**

<img src="%E7%BD%91%E7%BB%9C.assets/DNS.png" alt="DNS" style="zoom:150%;" />

1. 以询问 **baidu.com** 为例子
2. `浏览器` 从**本地缓存**中寻找  `IP 地址`
3. 如果没有, 则向 **运营商** 询问 `IP 地址`
4. 运营商 向 **根服务器( 存储域名服务器的 IP 地址 )** 询问 `IP 地址`, 返回 **域名服务器** 的 `IP 地址` 
5. 运营商 向 **域名服务器( TLD SERVER, 储存 .com, .cn 等域名所对应的服务器 )** 询问 `IP 地址` , 返回存储所有 `.com 域名` 的服务器 `IP 地址`
6. 运营商 向 **Name Server** 询问 `IP 地址` , 返回 `baidu.com` 的 `IP 地址`
7. 运营商将 `baidu.com 的 IP 地址` 保存在缓存中, 向服务器返回 `IP 地址`



# TCP

## **TCP Header**

![Screenshot from 2021-04-07 23-25-35](%E7%BD%91%E7%BB%9C.assets/Screenshot%20from%202021-04-07%2023-25-35.png)



## **三次握手**



![sanci](file://D:\Note\Java-Backend-Note\Java\Java.assets\sanci.png?lastModify=1634365866)







## **四次挥手**

![sici](file://D:\Note\Java-Backend-Note\Java\Java.assets\sici-1622277304896.png?lastModify=1634365814)





# UDP

## UPD 头





# 八股文

## 在 TCP 中, 为什么是三次握手而不是两次握手



+ 防止过期报文传回服务器
  1. 假设客户端发送第一次连接 A, 没有收到 第二次握手 的报文
  2. 于是又发送 第二次连接 B, 这一次正常




+ 确认自己和对方的发送能力和接收能力正常

  1. 第一次握手

     > 1. **客户端 **确认自己有 **发送能力**, 服务端什么都没有
     > 2. **服务端 **暂时确认自己和客户端都没有 **发送和接收能力**

  2. 第二次握手

     > 1. **客户端 **确认自己有 接收能力, 服务端有 发送和接收能力
     > 2. **服务端 **确认自己有 **发送能力和接收能力** , 客户端有 **发送能力**

  3. 第三次握手

     > 1. 客户端和服务端 **都确认** 自己和对方有 **发送和接收能力**




+ 确认自己的 seq 和对方的 seq



#### [拓展] 两军问题

+ **场景**

  1. 红军和蓝军进行通信, 两者的信使都有 **一定概率失踪**
  2. 红军和蓝军约定一起进攻白军
  3. 红军派出信使
  4. 蓝军收到, 并且也派出信使回复
  5. 红军收到, 并且也派出信使回复
  6. 蓝军收到, 并且也派出信使回复......
  7. **因为信使存在 失踪(丢失) 的问题, 所以每一次任意一方收到信息, 都需要进行回复, 无法得到确切的消息.** 
  8. ***即 在不可靠的信道上( 信使 ), 无法建立可靠的 连接***




+ **TCP 握手次数**
  1. 根据 **两军问题** 可知,  三次握手是能保证 双方可能进行正常通信的最少次数



## 四次挥手中, TIME_WAIT 的作用

1. 如果只有 **第三次挥手**, 客户端没有接收到, 因为有 `TIME-WAIT` , 所以客户端可以收到服务端 `重传的报文` , 双方得以顺利关闭连接.
2. 经过 `TIME-WAIT` 后, 本次连接产生的全部报文都会在 **网络中消失**, 不会干扰到下一次的连接. 