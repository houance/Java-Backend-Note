# 刷题技巧

[toc]

## 双指针

+ **快慢指针**

  + **判断链表是否有环**

    ```java
    // 因为环的位置可能在链表的任何位置
    // 所以设置快慢指针, 快的每次走 两格, 慢的走 一格
    // 如果存在环, 则快指针 一定可以追上 慢指针
    // 否则快指针就到了 null
    boolean hasCycle(ListNode head) {
        ListNode fast, slow;
        
        // 快慢指针同起点出发
        fast = slow = head;
        
        // 判断快指针是否到 终点( null )
        // 判断快指针 下一格是否是终点( 方便快指针走两格 )
        while (fast != null && fast.next != null) {
            
            // 快指针每次走两格
            fast = fast.next.next;
            
            // 慢指针每次走一格
            slow = slow.next;
    
            // 如果快慢指针相遇, 则有环
            if (fast == slow) return true;
        }
        return false;
    }
    ```

    

  + **已知链表有环， 返回环的起始位置**

    ```java
    // 先找出快慢指针 第一次相遇 的地方
    // 然后将 慢指针指向链表头部
    // 两个指针此时设置为 同速前进
    // 再次相遇的地方, 则为环的起点
    ListNode detectCyclePoint(ListNode head) {
        
        // 先找出第一次相遇的地方
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        
        // 判断是否存在环
        if (fast == null || fast.next == null) {
            // fast 遇到空指针说明没有环
            return null;
        }
    
        // 设置为同速
        // 再次相遇, 则为环的起点
        slow = head;
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
    ```

    + **原理**

      > 1. 快指针 `任意时刻` 的路程是 `慢指针的两倍`
      >
      > 2. 所以**第一次相遇**的时候, 假设慢指针走了 K 步
      >    则快指针走了 2K 步
      >
      > 3. 则 `K 为环的长度的整数倍`
      >
      >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/3.jpeg" alt="3" style="zoom:150%;" />
      >
      > 4. 此时设**环的起点**距离 `相遇位置为 m`
      >
      >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/2.jpeg" alt="2" style="zoom:150%;" />
      >
      > 5. 将`慢指针指向链表头部`, 两个指针 `同速前进`, 经过 `k - m` 的距离之后, 两者`在环的起点相遇`.

  + **寻找链表的中点**

    ```java
    // 快指针 `任意时刻` 的路程是 `慢指针的两倍`
    // 快指针到达链表尽头, 则慢指针在链表中间
    ListNode middleNode(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // slow 就在中间位置
        return slow;
    }
    ```

  + **删除链表倒数第 n 个的结点**

    ```java
    // 快指针先走 n 步
    // 然后快慢指针 同速前进
    // 当快指针到链表尾部时, 
    // 慢指针就在 倒数第 n 个结点的前一个结点
    
    ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast, slow;
        fast = slow = head;
        
        // 快指针先前进 n 步
        while (n-- > 0) {
            fast = fast.next;
        }
        
        // 慢指针还没有开始走的时候,
        // 如果此时 快指针 走到链表尾部了，
        // 说明倒数第 n 个节点就是第一个节点
        if (fast == null) {
    
            return head.next;
        }
        
        // 让慢指针和快指针同步向前
        while (fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        // slow.next 就是倒数第 n 个节点，删除它
        slow.next = slow.next.next;
        return head;
    }
    ```

    

+ **左右指针**

  + **二分查找**

  + **在有序数组中寻找给定的两数之和**

    ```java
    // 输入 : 有序数组, 目标和
    // 输出 : 两个数的位置
    int[] twoSum(int[] nums, int target) {
        
        // 初始化 左右指针
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int sum = nums[left] + nums[right];
            
            // 找到则返回两数位置
            if (sum == target) {
                return new int[]{left, right};
            } 
            
            // 如果两数之和 比目标小
            // 则左指针 右移一位
            else if (sum < target) {
                left++; // 让 sum 大一点
            } 
            // 如果两数之和 比目标大
            // 则右指针 左移一位
            else if (sum > target) {
                right--; // 让 sum 小一点
            }
        }
        
        // 没找到则返回 -1
        return new int[]{-1, -1};
    }
    ```

    

  + **翻转数组**

    ```java
    void reverseString(char[] arr) {
        
        //初始化左右指针
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            // 交换 arr[left] 和 arr[right]
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            
            // 收缩翻转范围
            left++; right--;
        }
    }
    ```

    

## 数组 - 二分查找 - 左右指针

+ **二分查找框架**

  ```java
  // 输入 : 有序数组, 目标值
  // 输出 : 返回目标值在数组中的 左/中/右位置, 没有则返回-1 
  int binarySearch(int[] nums, int target) {
      int left = 0, right = num.length -1 ;
  
      while(left <= right) {
          
          // 确定每次查找的 中间位置
          int mid = left + (right - left) / 2;
          
        	// 命中
          // 根据 左右查找 的不同 返回不同坐标值
          if (nums[mid] == target) {
              ...
          }
          
          // 因为目标值在 mid 右边
          // 所以收缩 左边界
          else if (nums[mid] < target) {
              left = mid + 1
          }
          
          // 因为目标值在 mid 左边
          // 所以收缩 右边界
          else if (nums[mid] > target) {
              right = mid - 1
          }
      }
      
      // 后处理代码
      return ...;
}
  ```

  + **基本二分查找**
  
    > 1. 命中返回坐标, 否则返回 -1
    >
    > 2. **命中的处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    return mid;
    >    
    >    // 没有命中处理代码
    >    return -1;
    >    ```
    > 3. **没有后处理代码**


​    

  + **左边界二分查找**

    > 1. 返回`从左到右, 第一个命中`的坐标, 否则返回 -1
    >
    > 2. **命中处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    // 因为需要返回左边界,
    >    // 所以命中之后, 需要收缩 搜索范围的右界
    >    // 即从命中位置的左边开始找 是否可能命中
    >    right = mid - 1
    >    ```
    >
    > 
    >
    > 3. **后处理代码**
    >
    >    ```java
    >    // 数组可能存在越界行为
    >    // left 指针在数组右边越界
    >    // 需要检测是否越界
    >    if (left >= nums.length || nums[left] != target)
    >        return -1;
    >    
    >    // 如果没有越界, 则返回 left 指针
    >    return left;
    >    ```
    >
    > 

  + **右边界二分查找**

    > 1. 返回`从右到左, 第一个命中`的坐标, 否则返回 -1
    >
    > 2. **命中处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    // 因为需要返回右边界,
    >    // 所以命中之后, 需要收缩 搜索范围的下界
    >    // 即从命中位置的右边开始找 是否可能命中
    >    left = mid + 1
    >    ```
    >
    >    
    >
    > 3. **后处理代码**
    >
    >    ```java
    >    // 数组可能存在越界行为
    >    // right 指针在数组左边越界
    >    // 需要检测是否越界
    >    if (right < 0 || nums[right] != target)
    >        return -1;
    >    
    >    // 如果没有越界, 则返回 right 指针
    >    return right;
    >    ```
    >
    > 

## 字符串 - 滑动窗口 - 左右指针

+ **最小覆盖子串**

  ```java
  // 输入 : 源字符串, 目标字符串
  // 输出 : 源字符串中 包含目标字符串 的 最小子串(不保证顺序)
  
  
  
  
  public static String SlideWindowMethod(String source, 
                                         String target)
  {
  
          char[] sourceChars = source.toCharArray();
          char[] targetChars = target.toCharArray();
  
      	// mapWindow 字典 保存窗口内 符合目标串的字符
      	// 如果目标串有重复字符, 则对应字典值为 重复的次数
      	// 没有则为 1
          Map<Character, Integer> mapWindow = new HashMap<>();
  
      	// 初始化 mapNeed 字典, 保存目标串
          // 如果目标串有重复字符, 则对应字典值为 重复的次数
      	// 没有则为 1
      	Map<Character, Integer> mapNeed = new HashMap<>();
          for (char c : targetChars){
              mapNeed.put(c, mapNeed.getOrDefault(c, 0) + 1);
          }
  
  
      	// left, right 指针 维护窗口大小
      	// start, length 保存 最小子串的 起点和长度
      	// vaild 检查窗口是否存在最小子串
          int start,left, right, length, valid;
          start = left = right = vaild = 0;
      
      	// length 设最大, 方便第一次的 最小子串更新
          length = Integer.MAX_VALUE;
          while (right < source.length()){
              
              // 保存 right 指针的字符, 然后 right 指针滑动一格
              char charInput = sourceChars[right];
              right++;
              
              // 如果 right 指针指向的是目标串的字符
              if (mapNeed.containsKey(charInput)){
                  
              	// 则 mapWindow 字典存入 <charInput, 1>
              	// 如果 mapWindow 字典已经存在该字符, 
              	// 则 <charInput, value++>
                  mapWindow.put(charInput, mapWindow.getOrDefault(charInput, 0) + 1);
                  
                  // 更新 valid 值
                  // if 判断用于 目标穿存在重复字符的情况
                  if (mapWindow.get(charInput).equals(mapNeed.get(charInput)))
                      valid++;
              }
  
              // 收缩窗口
              while (valid == target.length()){
                  
                  // 更新 最小子串的 位置信息
                  if (right - left < length){
                      start = left;
                      length = right - left;
                  }
  
                  // 保存移出窗口的字符, 然后 left 指针右移一格
                  char charRemove = sourceChars[left];
                  left++;
                  
                  // 如果移出窗口的字符是目标串的
                  // 则更新 mapWindow 的数据
                  if (mapNeed.containsKey(charRemove)){
                      
                      // valid 自减, 停止收缩窗口
                      // mapWindow 字典对应值自减
                      valid--;
                     	mapWindow.put(charRemove, mapWindow.get(charRemove) - 1);
                  }
              }
          }
  
  
          if (length != Integer.MAX_VALUE)
              return source.substring(start, start + length);
          else return null;
      }
  ```

  

## 链表 - 递归

+ **综述**

  > 1. 链表具有 `递归` 的性质
  >
  > 2. 实现
  >
  >    ```java
  >    class ListNode{
  >        int val;
  >        ListNode next;
  >        ListNode(){}
  >        ListNode(int x){this.val = x;}
  >    }
  >    ```
  >
  >    

+ **链表递归的技巧**

  > 1. 

+ **遍历**

  ```java
  class ListNode{
      int val;
      ListNode next;
  }
  
  // 迭代访问
  void traverse(ListNode node){
      for(ListNode head = node;
          head != null;
          head = head.next){
          
      }
  }
  
  // 递归访问
  void traverse(ListNode node){
      
      if (node == null){
          return node;
      }
      else{
          traverse(node.next);
      }
  }
  ```

  

+ **递归翻转整个链表**

  + **递归函数定义**

    ```java
    // Input : 链表的头结点
    // Return : 翻转的链表的头结点
    public ListNode reverse(ListNode head);
    ```

  + **技巧**

    > 1. 从 `head.next 结点`开始递归
    >
    > 2. **base case**
    >
    >    > 1. 如果链表`只有一个结点` , 则 `返回头结点`( 翻转一个结点的翻转自己 )
    >
    > 3. **递归后处理**
    >
    >    > 1. `head.next 结点` 指向 `head 结点`
    >    > 2. `head 结点` 指向 `null`

  + **代码**

    ```java
    ListNode reverse(ListNode head) {
        // 递归终止条件
        if (head.next == null) return head;
        
        // 翻转 head.next 为起点的链表 
        // ( 链表递归固定套路 ) 
        ListNode last = reverse(head.next);
        
        // 递归之后的处理
        head.next.next = head;
        head.next = null;
        return last;
    }
    ```
    
  + **解释**

    > 1. 递归终止条件
    >
    >    > 翻转 `只有一个结点的链表` , 等于翻转自己
    >
    > 2. 翻转 `head.next 为起点的链表`
    >
    >    > 固定套路
    >    >
    >    > <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/digui.jpg" alt="digui" style="zoom:150%;" />
    >
    > 3. 递归之后的处理
    >
    >    > 1. 将 **结点2** 指向 **结点1**
    >    >
    >    >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/giguigui.jpg" alt="giguigui" style="zoom:150%;" />
    >    >
    >    > 2. 将 **结点1** 指向 **NULL**
    >    >
    >    >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/diguiguigui.jpg" alt="diguiguigui" style="zoom:150%;" />

+ **递归翻转链表的前 n 个结点**

  + **递归函数的定义**

    ```java
    // Input : 要翻转的链表的头结点, 要翻转的长度 n
    // Return : 翻转的链表的第一个结点
    public ListNode reverse(ListNode head, int n);
    ```

    

  + **技巧**

    > 1. 从 `head.next 结点` 开始递归
    >
    > 2. **后驱结点( successor )**
    >
    >    > 没有翻转前, `n 结点后的第一个结点`
    >
    > 3. **base case**
    >
    >    > 1. 链表**只有一个结点**时, 记录 `successor = head.next`
    >    > 2. 返回 `head 结点`
    >
    > 4. **后处理**
    >
    >    > 1. `head.next 结点` 指向 `head 结点`
    >    > 2. `head 结点` 指向 `successor 结点`

  + **代码**

    ```java
    ListNode successor = null;
    
    ListNode reverseN(ListNode head, int n) {
        if (n == 1) { 
            successor = head.next;
            return head;
        }
        
        ListNode last = reverseN(head.next, n - 1);
        
        head.next.next = head;
        head.next = successor;
        
        return last;
    }
    ```

    

+ **递归翻转从 m 到 n 的链表**
+ 

## 二叉树 - 递归

+ **二叉树实现**

  ```java
  public class TreeNode<T> {
      T value;
      TreeNode<T> leftNode;
      TreeNode<T> rightNode;
  }
  ```

  

+ **计算二叉树结点数**

  ```java
  // 输入 : 二叉树根结点
  // 输出 : 二叉树结点数 = 1( 根结点 ) + 左结点 + 右结点
  public static <T> Integer countNodeNums(TreeNode<T> rootNode){
      
      	// base case
          if (rootNode == null) return 0;
      
      	// 递归
          else return 1 + countNodeNums(rootNode.leftNode) + countNodeNums(rootNode.rightNode);
      }
  ```

  