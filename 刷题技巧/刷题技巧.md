# 刷题技巧

[toc]

## 数组

+ **二分查找框架**

  ```java
  int binarySearch(int[] nums, int target) {
      int left = 0, right = num.length -1 ;
  
      while(left <= right) {
          
          // 确定每次查找的 中间位置
          int mid = left + (right - left) / 2;
          
        	// 命中
          // 根据 左右查找 的不同 返回不同坐标值
          if (nums[mid] == target) {
              ...
          }
          
          // 因为目标值在 mid 右边
          // 所以收缩 左边界
          else if (nums[mid] < target) {
              left = mid + 1
          }
          
          // 因为目标值在 mid 左边
          // 所以收缩 右边界
          else if (nums[mid] > target) {
              right = mid - 1
          }
      }
      
      // 没有命中处理代码
      return ...;
  }
  ```

  + **基本二分查找**

    > 1. 命中返回坐标, 否则返回 -1
    >
    > 2. **命中的处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    return mid;
    >    
    >    // 没有命中处理代码
    >    return -1;
    >    ```

  + **左边界二分查找**

  + **右边界二分查找**



## 链表

+ **综述**

  > 1. 链表具有 `递归` 的性质
  >
  > 2. 实现
  >
  >    ```java
  >    class ListNode{
  >        int val;
  >        ListNode next;
  >        ListNode(){}
  >        ListNode(int x){this.val = x;}
  >    }
  >    ```
  >
  >    

+ **链表递归的技巧**

  > 1. 

+ **遍历**

  ```java
  class ListNode{
      int val;
      ListNode next;
  }
  
  // 迭代访问
  void traverse(ListNode node){
      for(ListNode head = node;
          head != null;
          head = head.next){
          
      }
  }
  
  // 递归访问
  void traverse(ListNode node){
      
      if (node == null){
          return node;
      }
      else{
          traverse(node.next);
      }
  }
  ```

  

+ **递归翻转整个链表**

  + **递归函数定义**

    ```java
    // Input : 链表的头结点
    // Return : 翻转的链表的头结点
    public ListNode reverse(ListNode head);
    ```

  + **技巧**

    > 1. 从 `head.next 结点`开始递归
    >
    > 2. **base case**
    >
    >    > 1. 如果链表`只有一个结点` , 则 `返回头结点`( 翻转一个结点的翻转自己 )
    >
    > 3. **递归后处理**
    >
    >    > 1. `head.next 结点` 指向 `head 结点`
    >    > 2. `head 结点` 指向 `null`

  + **代码**

    ```java
    ListNode reverse(ListNode head) {
        // 递归终止条件
        if (head.next == null) return head;
        
        // 翻转 head.next 为起点的链表 
        // ( 链表递归固定套路 ) 
        ListNode last = reverse(head.next);
        
        // 递归之后的处理
        head.next.next = head;
        head.next = null;
        return last;
    }
    ```
    
  + **解释**

    > 1. 递归终止条件
    >
    >    > 翻转 `只有一个结点的链表` , 等于翻转自己
    >
    > 2. 翻转 `head.next 为起点的链表`
    >
    >    > 固定套路
    >    >
    >    > <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/digui.jpg" alt="digui" style="zoom:150%;" />
    >
    > 3. 递归之后的处理
    >
    >    > 1. 将 **结点2** 指向 **结点1**
    >    >
    >    >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/giguigui.jpg" alt="giguigui" style="zoom:150%;" />
    >    >
    >    > 2. 将 **结点1** 指向 **NULL**
    >    >
    >    >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/diguiguigui.jpg" alt="diguiguigui" style="zoom:150%;" />

+ **递归翻转链表的前 n 个结点**

  + **递归函数的定义**

    ```java
    // Input : 要翻转的链表的头结点, 要翻转的长度 n
    // Return : 翻转的链表的第一个结点
    public ListNode reverse(ListNode head, int n);
    ```

    

  + **技巧**

    > 1. 从 `head.next 结点` 开始递归
    >
    > 2. **后驱结点( successor )**
    >
    >    > 没有翻转前, `n 结点后的第一个结点`
    >
    > 3. **base case**
    >
    >    > 1. 链表**只有一个结点**时, 记录 `successor = head.next`
    >    > 2. 返回 `head 结点`
    >
    > 4. **后处理**
    >
    >    > 1. `head.next 结点` 指向 `head 结点`
    >    > 2. `head 结点` 指向 `successor 结点`

  + **代码**

    ```java
    ListNode successor = null;
    
    ListNode reverseN(ListNode head, int n) {
        if (n == 1) { 
            successor = head.next;
            return head;
        }
        
        ListNode last = reverseN(head.next, n - 1);
        
        head.next.next = head;
        head.next = successor;
        
        return last;
    }
    ```

    

+ **递归翻转从 m 到 n 的链表**
+ 