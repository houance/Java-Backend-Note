# 刷题技巧

[toc]

## 双指针

+ **快慢指针**

  + **判断链表是否有环**

    ```java
    // 因为环的位置可能在链表的任何位置
    // 所以设置快慢指针, 快的每次走 两格, 慢的走 一格
    // 如果存在环, 则快指针 一定可以追上 慢指针
    // 否则快指针就到了 null
    boolean hasCycle(ListNode head) {
        ListNode fast, slow;
        
        // 快慢指针同起点出发
        fast = slow = head;
        
        // 判断快指针是否到 终点( null )
        // 判断快指针 下一格是否是终点( 方便快指针走两格 )
        while (fast != null && fast.next != null) {
            
            // 快指针每次走两格
            fast = fast.next.next;
            
            // 慢指针每次走一格
            slow = slow.next;
    
            // 如果快慢指针相遇, 则有环
            if (fast == slow) return true;
        }
        return false;
    }
    ```

    

  + **已知链表有环， 返回环的起始位置**

    ```java
    
    ```

    

+ **左右指针**

## 数组

+ **二分查找框架**

  ```java
  int binarySearch(int[] nums, int target) {
      int left = 0, right = num.length -1 ;
  
      while(left <= right) {
          
          // 确定每次查找的 中间位置
          int mid = left + (right - left) / 2;
          
        	// 命中
          // 根据 左右查找 的不同 返回不同坐标值
          if (nums[mid] == target) {
              ...
          }
          
          // 因为目标值在 mid 右边
          // 所以收缩 左边界
          else if (nums[mid] < target) {
              left = mid + 1
          }
          
          // 因为目标值在 mid 左边
          // 所以收缩 右边界
          else if (nums[mid] > target) {
              right = mid - 1
          }
      }
      
      // 后处理代码
      return ...;
  }
  ```

  + **基本二分查找**

    > 1. 命中返回坐标, 否则返回 -1
    >
    > 2. **命中的处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    return mid;
    >    
    >    // 没有命中处理代码
    >    return -1;
    >    ```
    > 3. **没有后处理代码**


​    

  + **左边界二分查找**

    > 1. 返回`从左到右, 第一个命中`的坐标, 否则返回 -1
    >
    > 2. **命中处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    // 因为需要返回左边界,
    >    // 所以命中之后, 需要收缩 搜索范围的右界
    >    // 即从命中位置的左边开始找 是否可能命中
    >    right = mid - 1
    >    ```
    >
    > 
    >
    > 3. **后处理代码**
    >
    >    ```java
    >    // 数组可能存在越界行为
    >    // left 指针在数组右边越界
    >    // 需要检测是否越界
    >    if (left >= nums.length || nums[left] != target)
    >        return -1;
    >    
    >    // 如果没有越界, 则返回 left 指针
    >    return left;
    >    ```
    >
    > 

  + **右边界二分查找**

    > 1. 返回`从右到左, 第一个命中`的坐标, 否则返回 -1
    >
    > 2. **命中处理代码**
    >
    >    ```java
    >    // 命中处理代码
    >    // 因为需要返回右边界,
    >    // 所以命中之后, 需要收缩 搜索范围的下界
    >    // 即从命中位置的右边开始找 是否可能命中
    >    left = mid + 1
    >    ```
    >
    >    
    >
    > 3. **后处理代码**
    >
    >    ```java
    >    // 数组可能存在越界行为
    >    // right 指针在数组左边越界
    >    // 需要检测是否越界
    >    if (right < 0 || nums[right] != target)
    >        return -1;
    >    
    >    // 如果没有越界, 则返回 right 指针
    >    return right;
    >    ```
    >
    > 



## 链表

+ **综述**

  > 1. 链表具有 `递归` 的性质
  >
  > 2. 实现
  >
  >    ```java
  >    class ListNode{
  >        int val;
  >        ListNode next;
  >        ListNode(){}
  >        ListNode(int x){this.val = x;}
  >    }
  >    ```
  >
  >    

+ **链表递归的技巧**

  > 1. 

+ **遍历**

  ```java
  class ListNode{
      int val;
      ListNode next;
  }
  
  // 迭代访问
  void traverse(ListNode node){
      for(ListNode head = node;
          head != null;
          head = head.next){
          
      }
  }
  
  // 递归访问
  void traverse(ListNode node){
      
      if (node == null){
          return node;
      }
      else{
          traverse(node.next);
      }
  }
  ```

  

+ **递归翻转整个链表**

  + **递归函数定义**

    ```java
    // Input : 链表的头结点
    // Return : 翻转的链表的头结点
    public ListNode reverse(ListNode head);
    ```

  + **技巧**

    > 1. 从 `head.next 结点`开始递归
    >
    > 2. **base case**
    >
    >    > 1. 如果链表`只有一个结点` , 则 `返回头结点`( 翻转一个结点的翻转自己 )
    >
    > 3. **递归后处理**
    >
    >    > 1. `head.next 结点` 指向 `head 结点`
    >    > 2. `head 结点` 指向 `null`

  + **代码**

    ```java
    ListNode reverse(ListNode head) {
        // 递归终止条件
        if (head.next == null) return head;
        
        // 翻转 head.next 为起点的链表 
        // ( 链表递归固定套路 ) 
        ListNode last = reverse(head.next);
        
        // 递归之后的处理
        head.next.next = head;
        head.next = null;
        return last;
    }
    ```
    
  + **解释**

    > 1. 递归终止条件
    >
    >    > 翻转 `只有一个结点的链表` , 等于翻转自己
    >
    > 2. 翻转 `head.next 为起点的链表`
    >
    >    > 固定套路
    >    >
    >    > <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/digui.jpg" alt="digui" style="zoom:150%;" />
    >
    > 3. 递归之后的处理
    >
    >    > 1. 将 **结点2** 指向 **结点1**
    >    >
    >    >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/giguigui.jpg" alt="giguigui" style="zoom:150%;" />
    >    >
    >    > 2. 将 **结点1** 指向 **NULL**
    >    >
    >    >    <img src="%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7.assets/diguiguigui.jpg" alt="diguiguigui" style="zoom:150%;" />

+ **递归翻转链表的前 n 个结点**

  + **递归函数的定义**

    ```java
    // Input : 要翻转的链表的头结点, 要翻转的长度 n
    // Return : 翻转的链表的第一个结点
    public ListNode reverse(ListNode head, int n);
    ```

    

  + **技巧**

    > 1. 从 `head.next 结点` 开始递归
    >
    > 2. **后驱结点( successor )**
    >
    >    > 没有翻转前, `n 结点后的第一个结点`
    >
    > 3. **base case**
    >
    >    > 1. 链表**只有一个结点**时, 记录 `successor = head.next`
    >    > 2. 返回 `head 结点`
    >
    > 4. **后处理**
    >
    >    > 1. `head.next 结点` 指向 `head 结点`
    >    > 2. `head 结点` 指向 `successor 结点`

  + **代码**

    ```java
    ListNode successor = null;
    
    ListNode reverseN(ListNode head, int n) {
        if (n == 1) { 
            successor = head.next;
            return head;
        }
        
        ListNode last = reverseN(head.next, n - 1);
        
        head.next.next = head;
        head.next = successor;
        
        return last;
    }
    ```

    

+ **递归翻转从 m 到 n 的链表**
+ 