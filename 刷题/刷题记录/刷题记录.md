# 刷题记录

[toc]

## 左右指针

### 三数之和

+ **题目**

  > 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，`使得 a + b + c = 0`？请你找出所有和为 0 `且不重复`的三元组。
  >
  > > ```
  > > 输入：nums = [-1,0,1,2,-1,-4]
  > > 输出：[[-1,-1,2],[-1,0,1]]
  > > ```

+ **解法**

  > 1. 数组排序 ( 从小到大 )
  >
  > 2. 三数之和的求解
  >
  >    > 1. 指定一个 nums[i]
  >    > 2. 使用 `双指针--左右指针` 求解, 类似两数之和
  >
  > 3. 三元组不重复的 `base case`
  >
  >    > 1. 如果 **nums[L] == nums[L+1] || nums[R]==nums[R-1]**, 说明解重复了, `因为在指定 nums[i] 和 nums[L/R] 时, 存在唯一解`, 此时应该 `缩小范围求解( 移动 L,R 指针)`
  >
  > 4. 代码框架( 两数之和, 三数之和, ...... )
  >
  >    ```java
  >    for(int i=0;i<length;i++){
  >        
  >        // 判断 nums[i] 的 base case
  >        // 初始化 左右指针
  >        
  >        // 左右指针遍历求解
  >        while(L < R){
  >            
  >            // 求三数之和
  >            // 判断 L,R base case
  >            // 移动 L,R 指针
  >        }
  >        
  >    }
  >    ```
  >
  >    

+ **代码**

  ```java
  public static List<List<Integer>> threeSum(int[] nums) {
      
      List<List<Integer>> ans = new ArrayList<>();
      int len = nums.length;
      if(len < 3) return ans;
      
      // 排序
      Arrays.sort(nums); 
      
      for (int i = 0; i < len ; i++) {
          
          // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
          if(nums[i] > 0) break; 
          
          // 如果 nums[i] = nums[i-1], 说明结果重复
          // 因为每次遍历 nums[i] 都会寻找全部解
          if(i > 0 && nums[i] == nums[i-1]) continue; 
          
          // 初始化 左右指针
          int L = i+1;
          int R = len-1;
          
          // 双指针--左右指针
          while(L < R){
              int sum = nums[i] + nums[L] + nums[R];
              if(sum == 0){
                  ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                  
  				// 使用 while 遍历去重
                  while (L<R && nums[L] == nums[L+1]) L++;
                  while (L<R && nums[R] == nums[R-1]) R--;
                  
                  // 遍历求 nums[i] 的情况的所有解
                  L++;
                  R--;
              }
              else if (sum < 0) L++;
              else R--;
          }
      }
      return ans;
  }
  ```
  
  

## 链表

### 两数相加

+ **题目**

  > 给你两个 `非空` 的链表，表示`两个非负的整数`。它们每位数字都是按照 `逆序` 的方式存储的，并且每个节点只能存储 一位 数字。
  >
  > 请你将两个数相加，并`以相同形式`返回一个表示和的链表。
  >
  > 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
  >

+ **解法**

  > 1. 因为两个数都是`逆序排列的`, 所以可以将链表`对应结点`的每个数相加, `长度不一样则补零`
  > 2. 以下为相加的时候需要解决的`边界条件`

  1. **情况 1**

     > 1. 两个结点相加`小于 10`
     > 2. 则新建结点 `储存两个结点之和`

     <img src="%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Untitled%20Diagram.png" alt="Untitled Diagram" style="zoom:150%;" />

  2. **情况 2**

     > 1. 两个结点相加`大于等于 10`
     > 2. 则新建结点储存 `两个结点的和除以 10 的余数`
     > 3. 记录进位

     ![Untitled Diagram (2)](%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Untitled%20Diagram%20(2).png)

  3. **情况 3**

     > 1. 两个结点相加`大于等于 10` 并且`链表遍历完毕`
     > 2. 需要在新链表的`最后面添加结点 1(结点存储的值为 1)`

     ![Untitled Diagram (3)](%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Untitled%20Diagram%20(3).png)

+ **代码**

  ```java
  public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
      
      // 链表求解函数小细节
      // 如果返回的是头结点
      // 需要预先新建一个 pre 和 cur 结点
      // 其中 pre --> cur
      // 而 cur --> 后面新增的结点
      // 因为链表构造过程需要指针移动，会导致头指针丢失，无法返回结果
      ListNode pre = new ListNode(0);
      ListNode cur = pre;
      int carry = 0;
      
      // 迭代遍历链表的细节
      // 迭代终止的条件是 结点本身非空
      while(l1 != null || l2 != null) {
          
          // 如果长度不一样, 则用零补足
          int x = l1 == null ? 0 : l1.val;
          int y = l2 == null ? 0 : l2.val;
          
          // 计算两数之和
          int sum = x + y + carry;
  
          // 如果没有进位, 则 carry 为零
          // 如果有进位, 则 carry 为 1
          // 因为 0 <= 两数 <= 9
          // 所以这样写可以把 情况1和情况2 都包含了
          carry = sum / 10;
          
          // 因为个位数和 10 取模等于它本身
          // 所以这样写可以把 情况1和情况2 都包含了
          sum = sum % 10;
          
          // 追加结点
          // 移动指针
          cur.next = new ListNode(sum);
          cur = cur.next;
  
          // 链表长度一样, 则两个链表的指针都移动
          // 如果长度不一样, 且短的那个 移动到尾结点, 则只移动长的链表
          if(l1 != null)
              l1 = l1.next;
          if(l2 != null)
              l2 = l2.next;
      }
      
      // 情况三
      if(carry == 1) {
          cur.next = new ListNode(carry);
      }
      return pre.next;
  }
  ```






## 动态规划

### 爬楼梯

+ **题目**

  > 1. 假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。
  >
  > 2. 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
  >
  > 3. **注意：**给定 *n* 是一个正整数。
  >
  >    ![Screenshot from 2021-04-25 16-01-09](%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Screenshot%20from%202021-04-25%2016-01-09.png)

+ **解法**

  > 1. 状态变量 `n 为阶梯数`
  > 2. 状态方程 `f(n) = 方法数`
  > 3. **base case** 为 `f(1) = 1, f(2) = 2`
  > 4. 状态转移方程 `f(n) = f(n-1) + f(n-2)`

+ **代码**

  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  class Solution {
      public static int climbStairs(int n) {
          List<Integer> dp = new ArrayList<>();
          
          // 初始化 dp
          dp.add(0,0);
          dp.add(1,1);
          dp.add(2,2);
  
          // base case
          if (n==1){
              return dp.get(1);
          }
  
          else if (n==2){
              return dp.get(2);
          }
  
  		// 填充 dp 数组
          else {
              for (int i = 3; i <= n; i++) {
                  
                  // 状态转移方程
                  dp.add(dp.get(i - 1) + dp.get(i - 2));
              }
          }
          return dp.get(n);
      }
  }
  ```

  

### 凑硬币

+ **题目**

  > 1. 有 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，
  >
  > 2. 现在有总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。
  >
  >    ![Screenshot from 2021-04-25 16-05-42](%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Screenshot%20from%202021-04-25%2016-05-42.png)

+ **解法**

  > 1. 状态变量 `n 为需要凑的金额`
  >
  > 2. 状态方程 ` f(n) = 凑金额 n 需要的最少硬币数`
  >
  > 3. **base case**, 为 `f(0) = 0, f(n<0) = -1, f(coin) = 1`
  >
  > 4. 状态转移方程
  >
  >    > `f(n) = min{ f( n - coin ) + 1 | `
  >    >
  >    > `coin belongs coins }`

+ **代码**

  ```java
  // 输入 : 硬币面值, 需要凑的金额
  // 输出 : 最少硬币数
  public static int coinChange(int[] coins, 
                               int amount){
  	
      // 小技巧, 初始化为无穷大或者无穷小, 方便后续取值, 
      // 也被称为哨兵技巧
  
      // dp 数组的长度和值初始化为 amount + 1
      // 即储存最傻的凑硬币方法, 全部用 1 元硬币存储
      // +1 是相当于初始化为无穷大, 方便取值比较
      List<Integer> dp = new ArrayList<>();
      for (int i=0;i<amount+1;i++){
          dp.add(amount + 1);
      }
      // DP Table 的第一个位置一般不用
      dp.set(0, 0);
      
      // 求解 DP Table
      for (int i=0;i<dp.size();i++){
          
          // 遍历每种面值
          // 储存(金额 - 每个硬币面值的情况下) 的 
          // 最小硬币数 + 1
          for (int coin : coins){
              if (i - coin < 0) continue;
              
              // 之所以写 Math.min
              // (dp.get(i), dp.get(i - coin) + 1))
              // 是因为这种写法是
              // 先将第一种的硬币面值的最少硬币数
              // 写入 DP Table 对应位置
              // 然后后面的各种硬币面值的最少硬币数
              // 如果比前一种小,才写入 DP Table
              dp.set
                  (i, Math.min
                   (dp.get(i), dp.get(i - coin) + 1));
          }
      }
  
      return (dp.get(amount).equals(amount + 1) ? -1:dp.get(amount));
  }
  ```

  

