# 刷题记录

[toc]

## 左右指针

### 三数之和

+ **题目**

  > 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，`使得 a + b + c = 0`？请你找出所有和为 0 `且不重复`的三元组。
  >
  > > ```
  > > 输入：nums = [-1,0,1,2,-1,-4]
  > > 输出：[[-1,-1,2],[-1,0,1]]
  > > ```

+ **解法**

  > 1. 数组排序 ( 从小到大 )
  >
  > 2. 三数之和的求解
  >
  >    > 1. 指定一个 nums[i]
  >    > 2. 使用 `双指针--左右指针` 求解, 类似两数之和
  >
  > 3. 三元组不重复的 `base case`
  >
  >    > 1. 如果 **nums[L] == nums[L+1] || nums[R]==nums[R-1]**, 说明解重复了, `因为在指定 nums[i] 和 nums[L/R] 时, 存在唯一解`, 此时应该 `缩小范围求解( 移动 L,R 指针)`
  >
  > 4. 代码框架( 两数之和, 三数之和, ...... )
  >
  >    ```java
  >    for(int i=0;i<length;i++){
  >        
  >        // 判断 nums[i] 的 base case
  >        // 初始化 左右指针
  >        
  >        // 左右指针遍历求解
  >        while(L < R){
  >            
  >            // 求三数之和
  >            // 判断 L,R base case
  >            // 移动 L,R 指针
  >        }
  >        
  >    }
  >    ```
  >
  >    

+ **代码**

  ```java
  public static List<List<Integer>> threeSum(int[] nums) {
      
      List<List<Integer>> ans = new ArrayList<>();
      int len = nums.length;
      if(len < 3) return ans;
      
      // 排序
      Arrays.sort(nums); 
      
      for (int i = 0; i < len ; i++) {
          
          // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
          if(nums[i] > 0) break; 
          
          // 如果 nums[i] = nums[i-1], 说明结果重复
          // 因为每次遍历 nums[i] 都会寻找全部解
          if(i > 0 && nums[i] == nums[i-1]) continue; 
          
          // 初始化 左右指针
          int L = i+1;
          int R = len-1;
          
          // 双指针--左右指针
          while(L < R){
              int sum = nums[i] + nums[L] + nums[R];
              if(sum == 0){
                  ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                  
  				// 使用 while 遍历去重
                  while (L<R && nums[L] == nums[L+1]) L++;
                  while (L<R && nums[R] == nums[R-1]) R--;
                  
                  // 遍历求 nums[i] 的情况的所有解
                  L++;
                  R--;
              }
              else if (sum < 0) L++;
              else R--;
          }
      }
      return ans;
  }
  ```
  
  

## 链表

### 两数相加

+ **题目**

  > 给你两个 `非空` 的链表，表示`两个非负的整数`。它们每位数字都是按照 `逆序` 的方式存储的，并且每个节点只能存储 一位 数字。
  >
  > 请你将两个数相加，并`以相同形式`返回一个表示和的链表。
  >
  > 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
  >

+ **解法**

  > 1. 因为两个数都是`逆序排列的`, 所以可以将链表`对应结点`的每个数相加, `长度不一样则补零`
  > 2. 以下为相加的时候需要解决的`边界条件`

  1. **情况 1**

     > 1. 两个结点相加`小于 10`
     > 2. 则新建结点 `储存两个结点之和`

     <img src="%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Untitled%20Diagram.png" alt="Untitled Diagram" style="zoom:150%;" />

  2. **情况 2**

     > 1. 两个结点相加`大于等于 10`
     > 2. 则新建结点储存 `两个结点的和除以 10 的余数`
     > 3. 记录进位

     ![Untitled Diagram (2)](%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Untitled%20Diagram%20(2).png)

  3. **情况 3**

     > 1. 两个结点相加`大于等于 10` 并且`链表遍历完毕`
     > 2. 需要在新链表的`最后面添加结点 1(结点存储的值为 1)`

     ![Untitled Diagram (3)](%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/Untitled%20Diagram%20(3).png)

+ **代码**

  ```java
  public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
      
      // 链表求解函数小细节
      // 如果返回的是头结点
      // 需要预先新建一个 pre 和 cur 结点
      // 其中 pre --> cur
      // 而 cur --> 后面新增的结点
      // 因为链表构造过程需要指针移动，会导致头指针丢失，无法返回结果
      ListNode pre = new ListNode(0);
      ListNode cur = pre;
      int carry = 0;
      
      // 迭代遍历链表的细节
      // 迭代终止的条件是 结点本身非空
      while(l1 != null || l2 != null) {
          
          // 如果长度不一样, 则用零补足
          int x = l1 == null ? 0 : l1.val;
          int y = l2 == null ? 0 : l2.val;
          
          // 计算两数之和
          int sum = x + y + carry;
  
          // 如果没有进位, 则 carry 为零
          // 如果有进位, 则 carry 为 1
          // 因为 0 <= 两数 <= 9
          // 所以这样写可以把 情况1和情况2 都包含了
          carry = sum / 10;
          
          // 因为个位数和 10 取模等于它本身
          // 所以这样写可以把 情况1和情况2 都包含了
          sum = sum % 10;
          
          // 追加结点
          // 移动指针
          cur.next = new ListNode(sum);
          cur = cur.next;
  
          // 链表长度一样, 则两个链表的指针都移动
          // 如果长度不一样, 且短的那个 移动到尾结点, 则只移动长的链表
          if(l1 != null)
              l1 = l1.next;
          if(l2 != null)
              l2 = l2.next;
      }
      
      // 情况三
      if(carry == 1) {
          cur.next = new ListNode(carry);
      }
      return pre.next;
  }
  ```

  