# Mysql实战 45 讲-笔记

## MySQL 语句



## MySQL 基本架构

![Screenshot from 2021-02-24 23-20-36](Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-02-24%2023-20-36.png)

### 连接器

> 1. 客户端进程采用 `TCP/IP`、`命名管道或共享内存`、`Unix 域套接字`这几种方式之一连接 `服务端的数据库`
>2. 数据库进程 `新建线程` 处理连接 ( 断开连接后会 `缓存线程`, 留作下次使用 )
> 3. 数据库检查 账号, 密码, 主机信息, 然后 `赋予对应权限`
>
> > 1. 长连接 - 多个请求使用同一个连接, 默认时间 = 8 小时
> > 2. 短连接 - 执行几个请求后断开连接
> >
> > 3. **建立连接耗时长, 尽量使用长连接**
>
> > 1. 一个连接占用的内存只有 `断开连接` 后才会释放, 所以会 `累积`
> > 2. 内存占用过大, 会被电脑 `强行杀掉( OOM )` 
> >
> > 3. **定期断开重连**
> > 4. **执行内存占用大的请求后断开连接**
> > 5. **使用 reset_connection, 效果同 3**

### 查询缓存( 5.7 后已弃用, 使用 Redis 等缓存)

### 分析器

> 1. 服务端收到的请求是以 `文本` 的形式
> 2. 所以需要进行 `语法分析`( 类似代码的 `编译` )
> 3. 把需要操作的 `表名, 查询条件等信息` 提取出来

### 优化器

> 1. 用于优化 **语句** 的执行效率, 比如
> 2. 使用索引, 子查询转为连接, 优化表的连接顺序 等
> 3. 优化的结果是生成一个 `执行计划` 

### 执行器

> 1. 调用 `存储引擎` 的接口, 执行语句

### 存储引擎

> 1. **存储引擎**负责 `数据的存储和提取`
>
>    > 1. 即包括 在物理存储中管理表, 写入物理存储等
>    > 2. 不同 **存储引擎** 使用不同的方式管理数据
>
> 2. 不同的**存储引擎**都提供 `一致的 API`



## InnoDB 存储结构

### 页

+ **综述**

  > 1. **InnoDB** 使用 `页结构` 作为 `内存和磁盘` 的最基本交互单位
  >
  > 2. 即每次从 磁盘读入内存/内存写入磁盘 `至少一页` 数据
  >
  >    > 一页大概为 `16KB`

+ **结构**

  ![Screenshot from 2021-05-16 23-06-27](Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-05-16%2023-06-27.png)

### 行格式

##### 综述

> 1. 目前分为 **Compact, Redundant, Dynamic, Compressed**
> 2. 常用的就是 `Compact` 格式

##### Compact 格式详解

+ **结构**

  ![Screenshot from 2021-05-17 09-45-30](Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Screenshot%20from%202021-05-17%2009-45-30-1621232981224.png)

+ **变长字段长度列表**

  > 1. 储存



#### 行溢出数据

## MySQL 的索引

## MySQL 日志系统

### WAL ( Write-Ahead Logging, 日志先行 )

> 1. 数据文件 `进行修改前` ，必须 `将修改先记录日志`
>

### Redo Log ( 重做日志 ) 

#### 操作流程

<img src="Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram.png" alt="Untitled Diagram" style="zoom: 150%;" />

> 1. 修改 `内存` 中的 `Redo Log( 重做日志 )`
> 2. 修改 `内存` 中的 `数据`
> 3. 触发 `落盘规则` , 异步写入 `磁盘` 中的 日志和数据

#### 细节

> 1. 由 **InnoDB** 引擎 `产生和负责`
> 2. 记录的是 `数据页` 的改变
> 3. 比 直接 `写入磁盘` 快 `( 一次写一条记录 vs 一次写多条 )/( 随机写 vs 顺序写 )`
> 4. 使用 **Write Pos** 和 **Check Pos** 检查 `内存中` 日志是否写满来实现 `循环写` , 当 **Write Pos** 和 **Check Pos** 相遇时, 表示 `日志写满` . 将日志刷入磁盘后 `才能继续` 写日志.

<img src="Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram%20(1)-1614606805851.png" alt="Untitled Diagram (1)" style="zoom:150%;" />

### Undo Log ( 回滚日志 )

> 1. 记录 `相反` 的记录,  ( 如果是 Insert 则记录 Delete )

### Binlog ( 归档日志 )

> 1. 记录 Mysql 语句 ( 除了 `查询语句`  )
> 2. 写满后 `新建文件` 继续写, `文件过期` 才会自动清除
> 3. 如果 `写满后事务` 还没有提交, 则会 `增大文件` 继续写事务

#### **整体流程 ( 两阶段提交 )**

<img src="Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram-1614653827038.png" alt="Untitled Diagram" style="zoom:150%;" />

> 1. innodb_flush_log_at_trx_commit = 1, 会在记录 `Redo Log` 后调用 `fsync` 刷入磁盘
> 2. sync_binlog = 1, 会在记录 `BinLog` 后调用 `fsync` 刷入磁盘
> 3. 

#### 组提交 ( )

#### 数据恢复流程

### Linux 磁盘同步函数

> + **sync**
>
>   > 将修改放入 `磁盘同步队列` , 然后 `立即返回` , `并不等待` 实际写磁盘操作结束.
>
> + **fsync**
>
>   > 只对单一文件起作用，`等待写磁盘操作结束`，然后返回. 通常用于数据库应用
>
> + **fdatasyn**
>
>   > 与 `fsync` 相似, 但只更改数据部分, 不更改 `文件属性`

## MySQL 事务隔离级别

### **事务 ( Transcation )**

> 1. 由 `一系列`  Mysql 语句组成
>
> 2. 满足 `原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）`
>
>    > 1. 原子性 : `全部语句` 执行成功 或 失败
>    > 2. 一致性 : 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。即写入的数据 `符合规则 ( 数据类型约束...... )`
>    > 3. 隔离性 : 数据库允许多个事务并发执行, 隔离性保证多个事务的`数据一致性`
>    > 4. 持久性 : 事务结束后数据将永远 `被修改`

### **事务隔离级别**

#### Read Uncommited( 读未提交 )

> 1. 事务 `未提交 (uncommited) 的更改`可以被其他事务 `读取 (read)`
>
> 2. 即完全 `没有锁`

#### Read Commited ( 读提交 )

> 1. 事务 `提交(commited) 的更改`才可以被其他事务 `读取(read)`

#### Repeatable Read ( 可重复读 )

> 1. 事务`执行时读取(read)的数据`和`启动时读取(read)的数据`是一致的
> 2. 同 `Read Commited`

#### Serializable( 串行化 )

> 1. 对于 `同一行记录` , `读取(read)` 和 `写入(write)` 都会加锁, 两者冲突时`后启动的事务`必须等待`之前的事务提交后`才可以继续执行.
>
> 2. 其中, 并发读的时候加 `共享锁` , 即其他事务也可以读; 并发写的时候加 `排他锁` , 即其他事务不能读和写.

### **可重复读实现原理( Mysql 默认隔离级别)**

+ **实现重复读**

  > 1. 每个事务 `开始时` 会赋予一个版本号, 该版本号 `严格递增`
  > 2. 读取 版本号 <= `当前事务` 版本号的数据, 实现可重复读
  > 3. `当前事务内` 更新的数据也可以读取

+ **解决并发写**

  > + 有索引的情况
  >
  >   为 `写入的行` 加锁, 事务提交后释放
  >
  > + 没有索引的情况
  >
  >   为 `整个表` 加锁, 然后在筛选不符合条件的行后释放

+ **解决幻读**

  > 

## MySQL 的