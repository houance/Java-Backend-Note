# Distributed Lock - 分布式锁

## 为什么需要分布式锁

### JVM 锁

> 1. 对于 **同一进程( 通常指同一机器上 )** 内的 **线程**, 可以通过对 `共享资源` 上锁, 避免出现 `数据不一致` 的现象



### 微服务锁

> 1. 对于 **不在同一进程( 通常指不同机器上 )** 的线程, 如果需要对 `共享资源` 上锁, 此时 JVM 提供的锁已经不起作用, 则需要用到 `分布式锁`



## 分布式系统 CAP 理论

### Consistency( 一致性 ), Availability( 可用性 ), Partition-tolerance( 分区容忍性 )

> 1. **同一时间点**, 所有节点的 `数据是一致的`
> 2. 能够在 `正常时间段内` 做出响应
> 3. 当**一个分区失败( Fail )**, 其他分区 `可以提供正常的服务`

> 1. 一个分布式系统 **只能满足 CAP 中的两点**, `不可能同时满足三点`



## Redis 实现

### Set Key Value NX PX [time]

#### 参数解释

> 1. **NX** : `Key 不存在` 才能设置, 如果 `存在则返回 0`
>
>    > 1. 即实现 `互斥性`
>
> 2. **PX** : 经过 **time** 时间后 `自动删除 Key`
>
>    > 1. 防止进程 **长时间占用锁**, `导致死锁`



#### 加锁过程

> 1. 进程 A 尝试设置 Key, 并且 value 是 `唯一的 ( 比如 uuid , 时间戳...... )`
>
>    > 1. 使用唯一的标识, 用于在释放锁的时候, 检查该锁 `是否是自己持有`
>    > 2. 如果 value 不一致, 则不删除该 Key ( 即释放锁 ), 防止 `误删其他进程的锁`
>
> 2. 如果`设置成功`, 则继续执行操作, 否则 **自旋**



#### 缺点

> 1. 如果是单机部署, 则存在 `单点问题`
>
>    > 1. 如果 Redis 的 **机器挂了**, `则锁失效`
>
> 2. 如果是 **Master-Slave** 部署, 则存在 `锁丢失问题`
>
>    > 1. 因为 **Redis** 是`异步同步`, 如果 **Master** 挂了, 而 **锁还没有同步** 到 **Slave** 机器上, 会导致 `锁丢失`
>
> 3. 即该方法仅满足 `A, P 特性` 



### RedLock / Redisson

#### 参数解释

> 1. **TTL** : 锁过期时间
>
> 2. **N** : 部署 `N 个独立的 Redis 实例`, 彼此之间 `不同步`
>
>    > 1. 推荐使用 **奇数**
>    > 2. 因为如果为 **偶数**, 则会出现两个客户端 `都锁了一半的实例,造成死锁`
>
> 3. 获取锁的命令还是使用上述的命令





#### 加锁过程

> 1. 客户端获取 `当前时间戳`
>
> 2. 客户端依次 `从 N 个实例中获取锁`
>
>    > 1. 获取锁的 `等待时间` 应该 `远远小于 TTL`
>    > 2. 以防止因为某个 Redis 实例被挂起, 客户端`长时间等待` 导致 **获取锁失败**
>
> 3. 如果客户端 `成功获取 (N/2 + 1) 个锁`, 且`获取锁的时间小于锁过期时间`, 则认为 **锁获取成功**
>
>    > 1. **获取锁的时间** = 获取最后一把锁的时间戳 - 步骤一中的时间戳
>    > 2. **锁的实际可用时间** = 过期时间 - 获取锁的时间
>
> 4. 如果获取失败, 则客户端 `向全部 Redis 实例发送解锁命令`
>
>    > 1. 防止有一些实例收到命令, 因为网络问题没有回复



#### 失败重试







## Zookeeper 实现



## Mysql 实现

