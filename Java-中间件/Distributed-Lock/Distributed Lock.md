# Distributed Lock - 分布式锁

## 为什么需要分布式锁

### JVM 锁

> 1. 对于 **同一进程( 通常指同一机器上 )** 内的 **线程**, 可以通过对 `共享资源` 上锁, 避免出现 `数据不一致` 的现象



### 微服务锁

> 1. 对于 **不在同一进程( 通常指不同机器上 )** 的线程, 如果需要对 `共享资源` 上锁, 此时 JVM 提供的锁已经不起作用, 则需要用到 `分布式锁`



## 分布式系统 CAP 理论

### Consistency( 一致性 ), Availability( 可用性 ), Partition-tolerance( 分区容忍性 )

> 1. **同一时间点**, 所有节点的 `数据是一致的`
> 2. 能够在 `正常时间段内` 做出响应
> 3. 当**一个分区失败( Fail )**, 其他分区 `可以提供正常的服务`

> 1. 一个分布式系统 **只能满足 CAP 中的两点**, `不可能同时满足三点`



## Redis 实现

### Set Key Value NX PX [time]

#### 参数解释

> 1. **NX** : `Key 不存在` 才能设置, 如果 `存在则返回 0`
>
>    > 1. 即实现 `互斥性`
>
> 2. **PX** : 经过 **time** 时间后 `自动删除 Key`
>
>    > 1. 防止进程 **长时间占用锁**, `导致死锁`



#### 加锁过程

> 1. 进程 A 尝试设置 Key, 并且 value 是 `唯一的 ( 比如 uuid , 时间戳...... )`
>
>    > 1. 使用唯一的标识, 用于在释放锁的时候, 检查该锁 `是否是自己持有`
>    > 2. 如果 value 不一致, 则不删除该 Key ( 即释放锁 ), 防止 `误删其他进程的锁`
>
> 2. 如果`设置成功`, 则继续执行操作, 否则 **自旋**



#### 缺点

> 1. 如果是单机部署, 则存在 `单点问题`
>
>    > 1. 如果 Redis 的机器挂了, 则锁失效
>
> 2. 如果是 Master-Slave 部署, 则存在 `锁丢失问题`
>
>    > 1. 因为 **Redis** 是`异步同步`, 如果 **Master** 挂了, 而 **锁还没有同步** 到 **Slave** 机器上, 会导致 `锁丢失`
>
> 3. 即该方法仅满足 `A, P 特性` 



### RedLock



## Zookeeper 实现



## Mysql 实现