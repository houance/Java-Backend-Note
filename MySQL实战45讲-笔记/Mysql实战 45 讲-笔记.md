# Mysql实战 45 讲-笔记

[toc]

## 1. MySQL 基本架构

![Screenshot from 2021-02-24 23-20-36](/home/nopepsi/Pictures/Screenshot%20from%202021-02-24%2023-20-36.png)

1. **连接器**

   > 1. 检查 `账号`, `密码`
   >
   > 2. 赋予 `账号` 对应的权限
   >
   > > 1. 长连接 - 多个请求使用同一个连接, 默认时间 = 8 小时
   > > 2. 短连接 - 执行几个请求后断开连接
   > >
   > > 3. **建立连接耗时长, 尽量使用长连接**
   >
   > > 1. 一个连接占用的内存只有 `断开连接` 后才会释放, 所以会 `累积`
   > > 2. 内存占用过大, 会被电脑 `强行杀掉( OOM )` 
   > >
   > > 3. **定期断开重连**
   > > 4. **执行内存占用大的请求后断开连接**
   > > 5. **使用 reset_connection, 效果同 3**

2. **查询缓存( 5.7 后已弃用, 使用 Redis 等缓存)**

3. **分析器**

   > 1. 分析语法 ( 类似代码的 `编译` ) 

4. **优化器**

   > 1. 表存在 `多个索引` 时, 决定使用 `哪一个索引`
   > 2. 使用 `join` 语句是, 决定 `连接顺序`

5. **执行器**

   > 1. 调用 `存储引擎` 的接口, 执行语句

6. **存储引擎**

## 2. MySQL 日志系统

+ **WAL ( Write-Ahead Logging, 日志先行 )**

  > 1. 数据文件 `进行修改前` ，必须 `将修改先记录日志`
  >

+ **Redo Log ( 重做日志 )** 

  + 操作流程

    > 1. 修改 `内存` 中的 `Redo Log( 重做日志 )`
    > 2. 修改 `内存` 中的 `数据`
    > 3. 触发 `落盘规则` , 异步写入 `磁盘` 中的 日志和数据

    <img src="Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram.png" alt="Untitled Diagram" style="zoom: 150%;" />

  + 细节

    > 1. 由 InnoDB 引擎 `产生和负责`
    > 2. 记录的是 `数据页` 的改变
    > 3. 比 直接 `写入磁盘` 快 `( 一次写一条记录 vs 一次写多条 )/( 随机写 vs 顺序写 )`
    > 4. 使用 Write Pos 和 Check Pos 检查 `内存中` 日志是否写满来实现 `循环写` , 当 Write Pos 和 Check Pos 相遇时, 表示 `日志写满` . 将日志刷入磁盘后 `才能继续` 写日志.

    <img src="Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram%20(1)-1614606805851.png" alt="Untitled Diagram (1)" style="zoom:150%;" />

+ **Undo Log ( 回滚日志 )**

  > 1. 记录 `相反` 的记录,  ( 如果是 Insert 则记录 Delete )

+ **Binlog ( 归档日志 )**

  > 1. 记录 Mysql 语句 ( 除了 `查询语句`  )
  > 2. 写满后 `新建文件` 继续写, `文件过期` 才会自动清除
  > 3. 如果 `写满后事务` 还没有提交, 则会 `增大文件` 继续写事务

+ **整体流程 ( 两阶段提交 )**

  <img src="Mysql%E5%AE%9E%E6%88%98%2045%20%E8%AE%B2-%E7%AC%94%E8%AE%B0.assets/Untitled%20Diagram-1614653827038.png" alt="Untitled Diagram" style="zoom:150%;" />

  > 1. innodb_flush_log_at_trx_commit = 1, 会在记录 `Redo Log` 后调用 `fsync` 刷入磁盘
  > 2. sync_binlog = 1, 会在记录 `BinLog` 后调用 `fsync` 刷入磁盘
  > 3. 

+ **组提交 ( )**

+ **数据恢复流程**

+ **sync, fsync, fdatasyn ( Linux 磁盘同步函数 )**

  > + sync
  >
  >   > 将修改放入 `磁盘同步队列` , 然后 `立即返回` , `并不等待` 实际写磁盘操作结束.
  >
  > + fsync
  >
  >   > 只对单一文件起作用，`等待写磁盘操作结束`，然后返回. 通常用于数据库应用
  >
  > + fdatasyn
  >
  >   > 与 `fsync` 相似, 但只更改数据部分, 不更改 `文件属性`

## 3. MySQL 事务隔离级别

+ **事务 ( Transcation )**

  > 1. 由 `一系列`  Mysql 语句组成
  >
  > 2. 满足 `原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）`
  >
  >    > 1. 原子性 : `全部语句` 执行成功 或 失败
  >    > 2. 一致性 : 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。即写入的数据 `符合规则 ( 数据类型约束...... )`
  >    > 3. 隔离性 : 数据库允许多个事务并发执行, 隔离性保证多个事务的`数据一致性`
  >    > 4. 持久性 : 事务结束后数据将永远 `被修改`

+ **事务隔离级别**

  > 1. **Read Uncommited( 读未提交 )**
  >
  >    > 事务 `未提交 (uncommited) 的更改`可以被其他事务 `读取 (read)`
  >    >
  >    > 即完全 `没有锁`
  >
  > 2. **Read Commited ( 读提交 )**
  >
  >    > 事务 `提交(commited) 的更改`才可以被其他事务 `读取(read)`
  >
  > 3. **Repeatable Read ( 可重复读 )**
  >
  >    > 1. 事务`执行时读取(read)的数据`和`启动时读取(read)的数据`是一致的
  >    > 2. 同 `Read Commited`
  >
  > 4. Serializable( 串行化 )
  >
  >    > 对于 `同一行记录` , `读取(read)` 和 `写入(write)` 都会加锁, 两者冲突时`后启动的事务`必须等待`之前的事务提交后`才可以继续执行.
  >    >
  >    > 其中, 并发读的时候加 `共享锁` , 即其他事务也可以读; 并发写的时候加 `排他锁` , 即其他事务不能读和写.

+ **可重复读实现原理( Mysql 默认隔离级别)**

  + **实现重复读**

    > 1. 每个事务 `开始时` 会赋予一个版本号, 该版本号 `严格递增`
    > 2. 读取 版本号 <= `当前事务` 版本号的数据, 实现可重复读
    > 3. `当前事务内` 更新的数据也可以读取

  + **解决并发写**

    > + 有索引的情况
    >
    >   为 `写入的行` 加锁, 事务提交后释放
    >
    > + 没有索引的情况
    >
    >   为 `整个表` 加锁, 然后在筛选不符合条件的行后释放

  + **解决幻读**

    > 

## 4. MySQL 的索引

## 5. MySQL 的