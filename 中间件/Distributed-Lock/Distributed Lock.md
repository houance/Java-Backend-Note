# Distributed Lock - 分布式锁



## 为什么需要分布式锁

### JVM 锁

> 1. 对于 **同一进程( 通常指同一机器上 )** 内的 **线程**, 可以通过对 `共享资源` 上锁, 避免出现 `数据不一致` 的现象



### 微服务锁

> 1. 对于 **不在同一进程( 通常指不同机器上 )** 的线程, 如果需要对 `共享资源` 上锁, 此时 JVM 提供的锁已经不起作用, 则需要用到 `分布式锁`



## 分布式系统 CAP 理论

### Consistency( 一致性 ), Availability( 高可用性 ), Partition-tolerance( 分区容忍性 )

> 1. **同一时间点**, 所有节点的 `数据是一致的`
> 2. 能够在 `正常时间段内` 做出响应
> 3. 当**一个分区失败( Fail )**, 其他分区 `可以提供正常的服务`

> 1. 一个分布式系统 **只能满足 CAP 中的两点**, `不可能同时满足三点`



## Redis 实现

### Set Key Value NX PX [time]

#### 参数解释

> 1. **NX** : `Key 不存在` 才能设置, 如果 `存在则返回 0`
>
>    > 1. 即实现 `互斥性`
>
> 2. **PX** : 经过 **time** 时间后 `自动删除 Key`
>
>    > 1. 防止进程 **长时间占用锁**, `导致死锁`



#### 加锁过程

> 1. 进程 A 尝试设置 Key, 并且 value 是 `唯一的 ( 比如 uuid , 时间戳...... )`
>
>    > 1. 使用唯一的标识, 用于在释放锁的时候, 检查该锁 `是否是自己持有`
>    > 2. 如果 value 不一致, 则不删除该 Key ( 即释放锁 ), 防止 `误删其他进程的锁`
>
> 2. 如果`设置成功`, 则继续执行操作, 否则 **自旋**



#### 缺点

> 1. 如果是单机部署, 则存在 `单点问题`
>
>    > 1. 如果 Redis 的 **机器挂了**, `则锁失效`
>
> 2. 如果是 **Master-Slave** 部署, 则存在 `锁丢失问题`
>
>    > 1. 因为 **Redis** 是`异步同步`, 如果 **Master** 挂了, 而 **锁还没有同步** 到 **Slave** 机器上, 会导致 `锁丢失`
>
> 3. 即该方法仅满足 `A, P 特性` 

> 1. 所以 **Redis** 官方发布了 `RedLock` 算法, 解决 **单机** 和 **主从部署** 的问题



### RedLock

#### 参数解释

> 1. **TTL** : 锁过期时间
>
> 2. **N** : 部署 `N 个独立的 Redis 实例`, 彼此之间 `不同步`
>
>    > 1. 推荐使用 **奇数**
>    > 2. 因为如果为 **偶数**, 则会出现两个客户端 `都锁了一半的实例,造成死锁, 或者所谓的脑裂现象`
>



#### 加锁过程

> 1. 客户端获取 `当前时间戳`
>
> 2. 客户端依次 `从 N 个实例中获取锁`
>
>    > 1. 获取锁的 `等待时间` 应该 `远远小于 TTL`
>    > 2. 以防止因为某个 **Redis** 实例被挂起, 客户端`长时间等待` 导致 **获取锁失败**
>
> 3. 如果客户端 `成功获取 (N/2 + 1) 个锁`, 且`获取锁的时间小于锁过期时间`, 则认为 **锁获取成功**
>
>    > 1. **获取锁的时间** = 获取最后一把锁的时间戳 - 步骤一中的时间戳
>    > 2. **锁的实际可用时间** = 过期时间 - 获取锁的时间
>
> 4. 如果获取失败, 则客户端 `向全部 Redis 实例发送解锁命令`
>
>    > 1. 防止有一些实例收到命令, 因为 **网络问题** 没有回复, 导致 `锁没有正常释放`
>    > 2. 如果 **锁没有释放**, 则`只能等待锁自动过期`, 降低的 `分区容忍性` 



#### 失败重试

> 1. 获取锁失败后, 客户端 `延迟一段随机的时间`, 然后重新获取锁
>
> 2. 随即延迟一段时间, 降低多个客户端 `同时开始获取锁` 的概率
>
>    > 1. **同时获取锁** 意味着 `同时失败`, 这种情况 `非常影响性能`



#### 安全性分析 ( Martin - Antirez 讨论)

+ **数据一致性问题**

> 1. 如果客户端 A 获取锁后, 执行 **GC** 或者其他行为, 导致挂起时间 `超过了锁可用时间` 
> 2. 然后客户端 B 获取锁成功, 并操作共享资源
> 3. 此时客户端 A 醒来, 认为**自己仍然持有锁**, 并操作共享资源
> 4. 导致 `数据不一致`
> 5. `其他分布式锁` 也无法解决此类问题, 即只能保证锁的 `互斥性` , 不能保证 `顺序性`



+ **时间一致性问题**

> 1. **客户端** 的 `系统时钟可能会被更改( 比如在步骤三中将时间提前, 使客户端认为自己持有锁成功 )`,  即导致锁 **提前或者延后** 失效, 导致锁的 **互斥性失败**



+ **总结**

> 1. 时间一致性问题, 可以使用 `统一的外部时间系统` 解决 ( 比如时间服务器 )
>
> 2. 显然 **RedLock 算法** 存在 **数据不一致问题** , 如果需要 **更强的数据一致性**, 可以考虑使用 `辅助方法`
>
>    > 1. **Value** 存储 `自增变量` 或者 `uuid + ThreadId` 等用于标识的变量
>    > 2. 客户端带着 **Value** 去请求共享资源的服务器
>    > 3. 共享资源的服务器`根据 Value` 判断操作是否合理, 比如 **Value 小于当前自增变量**, 说明该数据是旧的, 则拒绝该请求
>    > 4. 不过这种辅助方法要求 **存储共享资源的服务器( 例如 Mysql )** 有这种功能, 即 `保证资源的互斥性`



## Zookeeper 实现



## Mysql 实现



## 总结

### RedLock 的方法

> 1. 需要的服务器资源较多
> 2. 因为获取锁失败后是不断重复尝试, 类似于 `自旋锁` , 在大部分情况下 `性能优越`



### Zookeeper 的方法

> 1. 需要的服务器资源较少
> 2. 通过监听事件获取锁, 类似于
> 3. 数据安全性比较强



### Mysql 的方法
