# 综述

*Zookeeper 是一个分布式的 **共识组件** . 也就是说, 它本身是分布式的, 同时它也被用在很多分布式系统中, 比如 Hadoop , Kafka......*





# 特性

1. 最终一致性

   > zookeeper 保证**最终一致性**, 也就是说, 你有可能读不到最新的消息

2. 原子性

   > 每一次写入都是以事务的形式进行, 也就是说, zookeeper 不支持 **并发写**

3. 适用于读多写少

   > 1. 数据存储在 **内存中**
   > 2. 每次写入都需要等一半以上的机器 **同步**

# 架构

![img](zookeeper.assets/5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg)

1. 架构形如一个树, 层次类似 ***文件系统***

# 结点和监听

1. 结点分为 ***持久化结点, 暂存结点, 持久化或者暂存顺序结点***

2. 每一个结点都由 **全局唯一** 的名称标记, 可以存放一定量的信息 ( 官方推荐 <1M )

3. **持久化结点**, 顾名思义, 一旦创建, 除非主动删除, 否则一直存在

4. **暂存结点**, 由客户端主动创建, 当客户端断开连接之后, 自动删除

   > 可以用于实现分布式锁

5. **顺序结点**, 即每一次创建结点, 都会由 zookeeper 负责加上一个序号前缀, ***保证在同一个父结点下, 该序号单调递增***

   > 同样适用于分布式锁

6. **客户端** 可以在结点上注册**监听事件**, 当结点发生某些变化( 新增结点, 结点删除...... ), 客户端可以立即感知这些变化



# 集群容灾

![img](zookeeper.assets/13918703-723d0ae46ab714a8.jpg)

1. 每一个 Server 都可以处理 **读操作( 但是不能保证是最新的 )**, 遇到写操作, 会把它转发到 Leader 上

2. ***只有 Leader 可以处理写操作***, 并且每一个写操作都是 串行执行的, 也就是说, zookeeper **不支持并发写**. Leader 会将写操作广播到集群中, 如果有半数的 Server 响应写入成功, 则此次写操作成功.

3. **Observer** 不参与到上述行为, 也不参与选举, 仅负责读操作和转发写操作

   > 用于提高 Zookeeper 的性能





# ZAB 算法



*ZAB( Zookeeper Atomic Broadcast - 原子广播算法 ) 用于同步集群中的所有 Server. 使用算法需要满足两个前提( 所有写操作由 **一台服务器负责**, 集群中存在 **Leader** )*



***前提:***

1. Leader 与每一个 Follower 之间存在一个 **点到点的 队列**



***ZAB 算法保证:***

1. 保证最终一致性
2. 如果 **Leader** 处理事务 A 先于事务 B, 那么在所有 **Follower** 中, ***这个顺序保持一致***



***过程如下( 类似二阶段提交 ) :***

1. Leader 为每一个写操作生成一个 **zxid**, 用于事务编号

   > zxid 是一个 64 位的数字, 高 32 位用于标识 Leader, 除非重新选举, 否则不会变; 低 32 位用于计数, 每次生成 Proposal 就自增

2. Leader 将具体的写操作和 **zxid** 通过**队列**发到 Follower

   > 写操作 + zxid = Proposal

3. Follower 处理写操作, 完成后发送 **ACK** 到 Leader

4. 当 Leader 接收到**超过一半机器数量的 ACK**, 那么就认为这次写操作 同步成功, 执行 Commit 并发送 Commit 指令到 Follower

5. Follower 执行 Commit

# 选举和 Paxos 算法