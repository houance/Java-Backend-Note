# 负载均衡算法

# 轮询 ( RoundRobin )

​	轮询, 即轮流分配流量, 一般会和 随机, 权重等方法结合使用. 对于负载均衡中间件来说, 一般只能做到 "假轮询", 因为真正的轮询需要一个 **全局的索引** , 记录上一次轮询的位置, 会带来锁开销. 一般实现会选择避免这个开销. 

​	轮询的方法被称为 静态的 , 因为请求被分配到的服务器从算法一开始就可以确定

+ 简单轮询 - 算法假设每个服务器拥有一样的性能
+ 权重轮询 - 权重高的节点被轮询的次数更多, 通过虚拟结点实现
+ 随机轮询 - 随机选择一个节点开始轮询, 解决单个服务器请求过多的问题



# 权重 ( Weighted )

​	权重, 即使用某种计算方法计算服务器的权重, 权重最高的服务器将会负责 **全部流量**. 

​	权重的方法被认为是 **动态的** ,因为权重会跟随时间变化, 请求被分配的服务器是 **不确定的**

+ 最少连接/权重 ( Weighted Least Connection/Bandwidth/Packet/...... )

  将请求分配到 **目前拥有最少连接数** 的服务器, 保证服务器不会被 **长连接** 拖垮. 如果服务器之间性能差别大, 可以通过**分配权重**来计算连接数.

  *公式 : Connection = Ture Connections / Server Weight*

+ 资源权重 ( Resources Based )

  通过在服务器部署一个 **Agent** 监控资源的多少来决定请求分配到哪一个服务器. 资源可以是自定义的 ( CPU 使用率, 内存...... ), 也可以是 **L2, L3, L4 ......** 等网络层的信息( 窗口, 拥塞...... )

+ 固定权重 ( Fixed Weight )

  通过自定义算法计算出 **权重最高** 的服务器, **全部流量** 将会分配到这台服务器, 直到请求失败, 才会计算出下一台权重最高的服务器. 

+ RTT 权重 ( Round Trip Time Weight )

  根据 Ping 的时间, 或者 Health Check 的时间, 找出 **响应最快** 的服务器, **全部流量** 将会分配到这台服务器. 算法总是会分配 **最快** 的服务器给用户



# 哈希 ( Hash )

​	通过自定义的值计算哈希值然后取余, 来确定请求分配到的服务器.

​	如果你希望通过哈希的方法将同样的客户端分配到同样服务器, 那么就要小心了, 因为哈希的方法依赖于服务器的数量 ( Hash(SomeID) % N(服务器数量) = ServerID ), 如果服务器的数量改变, 那么 ServerID 就改变了, 之前缓存的全部信息都会失效, 一般会采用 **一致性哈希** 解决这个问题. 更严格的来讲, **一致性哈希** 解决的是 **分布式缓存** 的不足.

+ IP 哈希 ( IP Hash )

  结合请求的 IP 和 服务器的 IP 进行哈希, 保证同样的客户端每次都会访问到同一台服务器, 可以用在需要 Session 的场景.

  IP 哈希的方法被认为是 **静态**

+ URL 哈希 ( URL Hash )

  对访问的 URL 进行哈希, 保证所有读写都会分配到对应的服务器上 ( 比如访问 site1 的请求只会分配到 server1, 不可能会分配到 server2 )

+ 一致性哈希 ( Consistent Hash )

  首先对服务器的 IP 哈希, 然后对 2^32 -1 取余 ( 旧方法是对 Server 数量取余 ), 然后放在一个 **哈希圆** 上( 长度就是 2^32 -1 ). 其次, 对 请求的 IP 哈希取余, 也放在 哈希圆 上. 此时, 请求顺时针行走, 碰到的第一个服务器就是被分配的服务器.

  为了解决服务器凑得太密的情况, 采用虚拟结点的方法. 即使用多个哈希函数对服务器取值( 如果服务器权重大, 可以多使用几个哈希函数 ), 得到多个虚拟结点, 再 Mapping 成一个服务器.

  ![img](https://miro.medium.com/max/855/1*PdXXrVOA_k9A18BD-ZNMfQ.png)



